using Xunit;

namespace WinRun.Agent.Tests;

/// <summary>
/// Tests that verify the C# protocol generator produces correct output.
/// These tests help catch generator bugs before they affect the codebase.
/// </summary>
public sealed class GeneratorTests
{
    // ========================================================================
    // Generator Script Existence
    // ========================================================================

    [SkippableFact]
    public void GeneratorProjectExists()
    {
        var projectPath = FindFile("guest/tools/GenerateProtocol/GenerateProtocol.csproj");
        Skip.If(projectPath == null, "Could not find repo root");
        Assert.True(File.Exists(projectPath));
    }

    [SkippableFact]
    public void ProtocolDefExists()
    {
        var protocolPath = FindFile("shared/protocol.def");
        Skip.If(protocolPath == null, "Could not find repo root");
        Assert.True(File.Exists(protocolPath));
    }

    [SkippableFact]
    public void GeneratedFileExists()
    {
        var generatedPath = FindFile("guest/WinRunAgent/Protocol.generated.cs");
        Skip.If(generatedPath == null, "Could not find repo root");
        Assert.True(File.Exists(generatedPath));
    }

    // ========================================================================
    // Generated File Content Validation
    // ========================================================================

    [SkippableFact]
    public void GeneratedFileHasAutoGeneratedHeader()
    {
        var content = ReadGeneratedFile();
        Skip.If(content == null, "Could not read generated file");

        Assert.Contains("AUTO-GENERATED FROM shared/protocol.def", content);
        Assert.Contains("DO NOT EDIT DIRECTLY", content);
    }

    [SkippableFact]
    public void GeneratedFileContainsExpectedTypes()
    {
        var content = ReadGeneratedFile();
        Skip.If(content == null, "Could not read generated file");

        // Core types
        Assert.Contains("public static class SpiceProtocolVersion", content);
        Assert.Contains("public enum SpiceMessageType", content);
        Assert.Contains("public enum GuestCapabilities", content);
        Assert.Contains("public enum MouseButton", content);
        Assert.Contains("public enum MouseEventType", content);
        Assert.Contains("public enum KeyEventType", content);
        Assert.Contains("public enum KeyModifiers", content);
        Assert.Contains("public enum DragDropEventType", content);
        Assert.Contains("public enum DragOperation", content);
        Assert.Contains("public enum PixelFormatType", content);
        Assert.Contains("public enum WindowEventType", content);
        Assert.Contains("public enum ClipboardFormat", content);
        Assert.Contains("public enum ProvisioningPhase", content);
    }

    [SkippableFact]
    public void GeneratedFileContainsBackwardsCompatAliases()
    {
        var content = ReadGeneratedFile();
        Skip.If(content == null, "Could not read generated file");

        Assert.Contains("GeneratedMessageType", content);
        Assert.Contains("GeneratedCapabilities", content);
        Assert.Contains("[Obsolete", content);
    }

    [SkippableFact]
    public void GeneratedFileHasFlagsAttributeOnCapabilities()
    {
        var content = ReadGeneratedFile();
        Skip.If(content == null, "Could not read generated file");

        // GuestCapabilities should have [Flags] attribute
        var capsIndex = content!.IndexOf("public enum GuestCapabilities");
        if (capsIndex > 0)
        {
            var beforeCaps = content[..capsIndex];
            Assert.Contains("[Flags]", beforeCaps[^100..]);
        }
    }

    // ========================================================================
    // Protocol.def Format Validation
    // ========================================================================

    [SkippableFact]
    public void ProtocolDefHasRequiredSections()
    {
        var content = ReadProtocolDef();
        Skip.If(content == null, "Could not read protocol.def");

        Assert.Contains("[VERSION]", content);
        Assert.Contains("[MESSAGE_TYPES_HOST_TO_GUEST]", content);
        Assert.Contains("[MESSAGE_TYPES_GUEST_TO_HOST]", content);
        Assert.Contains("[CAPABILITIES]", content);
        Assert.Contains("[MOUSE_BUTTONS]", content);
        Assert.Contains("[MOUSE_EVENT_TYPES]", content);
        Assert.Contains("[KEY_EVENT_TYPES]", content);
        Assert.Contains("[KEY_MODIFIERS]", content);
        Assert.Contains("[DRAG_DROP_EVENT_TYPES]", content);
        Assert.Contains("[DRAG_OPERATIONS]", content);
        Assert.Contains("[PIXEL_FORMATS]", content);
        Assert.Contains("[WINDOW_EVENT_TYPES]", content);
        Assert.Contains("[CLIPBOARD_FORMATS]", content);
        Assert.Contains("[PROVISIONING_PHASES]", content);
    }

    [SkippableFact]
    public void ProtocolDefMessageRangesAreCorrect()
    {
        var content = ReadProtocolDef();
        Skip.If(content == null, "Could not read protocol.def");

        var lines = content!.Split('\n');
        var inHostToGuest = false;
        var inGuestToHost = false;

        foreach (var line in lines)
        {
            if (line.Contains("[MESSAGE_TYPES_HOST_TO_GUEST]"))
            {
                inHostToGuest = true;
                inGuestToHost = false;
                continue;
            }
            if (line.Contains("[MESSAGE_TYPES_GUEST_TO_HOST]"))
            {
                inHostToGuest = false;
                inGuestToHost = true;
                continue;
            }
            if (line.StartsWith('['))
            {
                inHostToGuest = false;
                inGuestToHost = false;
                continue;
            }

            // Check for hex values
            var match = System.Text.RegularExpressions.Regex.Match(line, @"=\s*0x([0-9a-fA-F]+)");
            if (match.Success)
            {
                var value = Convert.ToInt32(match.Groups[1].Value, 16);
                if (inHostToGuest)
                {
                    Assert.True(value < 0x80, $"Host→Guest message '{line.Trim()}' should be < 0x80");
                }
                if (inGuestToHost)
                {
                    Assert.True(value >= 0x80, $"Guest→Host message '{line.Trim()}' should be >= 0x80");
                }
            }
        }
    }

    // ========================================================================
    // Helpers
    // ========================================================================

    private static string? FindFile(string relativePath)
    {
        var possibleRoots = new[]
        {
            Path.Combine("..", "..", "..", ".."),
            ".",
            Path.Combine("..", ".."),
            "/workspace"
        };

        foreach (var root in possibleRoots)
        {
            var fullPath = Path.Combine(root, relativePath);
            if (File.Exists(fullPath))
            {
                return fullPath;
            }
        }

        return null;
    }

    private static string? ReadGeneratedFile()
    {
        var path = FindFile("guest/WinRunAgent/Protocol.generated.cs");
        return path != null ? File.ReadAllText(path) : null;
    }

    private static string? ReadProtocolDef()
    {
        var path = FindFile("shared/protocol.def");
        return path != null ? File.ReadAllText(path) : null;
    }
}
